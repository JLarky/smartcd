#!/bin/bash

################################################################################
# bash_smartcd - cd with some oomph
#
#   Copyright (c) 2009-10 Dave Olszewski <cxreg@pobox.com>
#   http://github.com/cxreg/smartcd
#
#   This code is released under GPL v2 and the Artistic License, and
#   may be redistributed under the terms of either.
#
#
#   ###########
#   # Summary #
#   ###########
#
#   This replacement for bash's built-in cd function gives you the
#   ability to run bash_enter and bash_leave scripts for each of
#   the directories you are traveling between.  The scripts are run
#   in the expected order to the most common root between where you
#   are, and where you're going.  These files reside in a hierarchy
#   under your home directory which mirrors the directories they
#   represent, for example:
#
#       /foo/bar/baz  ->  ~/.smartcd/foo/bar/baz
#
#   ###############
#   # Basic usage #
#   ###############
#
#       # Install the library
#       cp .bash_smartcd ~
#
#       # Add it to your bash init script
#       . ~/.bash_smartcd
#       alias cd=smartcd
#
#       # And it works with pushd/popd too
#       alias pushd=smartpushd
#       alias popd=smartpopd
#
#       And if you are an "autocd" user, you may want
#       setup_smartcd_prompt_hook
#
#       # Edit the file to create some commands to run when entering
#       bash_enter -e
#
#       # Or done manually
#       echo 'echo "hi!"' > ~/.smartcd/somedir/bash_enter
#
#   This library combines very nicely with .bash_varstash to allow
#   you to set per-directory environment variables:
#
#       # bash_enter
#       stash PATH
#       export PATH=/something/extra:$PATH
#
#       # bash_leave
#       unstash PATH
#
#       # or the automagic version, which unstashes for you
#       autostash PATH
#       export PATH=/something/extra:$PATH
#
#   When a script is run by smartcd, it will announce that it has done
#   so unless SMARTCD_QUIET is set.
#
#   ########################
#   # Legacy mode (unsafe) #
#   ########################
#
#   The original version of this library was such that the scripts
#   containing the commands to run were themselves located in the
#   directory which they correspond to, named .bash_enter and
#   .bash_leave:
#
#       /foo/bar/baz  ->  /foo/bar/baz/.bash_enter
#
#   This was deemed unsafe, and the new scheme was adopted.  If you
#   prefer the old system and wish to accept the risk in doing so, you
#   can set SMARTCD_LEGACY=1 to allow the old behavior.  If you do not do
#   so, and a legacy script is found, it will *NOT* be invoked, and
#   instructions for migrating it to the new location will be displayed
#   (unless SMARTCD_QUIET is set).  If you set SMARTCD_AUTOMIGRATE=1 then
#   the migration steps will be executed for you whenever a legacy script
#   is found.
#
#   #############
#   # Templates #
#   #############
#
#   One advanced feature of smartcd is the ability to configure and use
#   templates for your enter and leave scripts.  If you often find yourself
#   creating very similar scripts with only minor differences, templates can
#   help.  This is primarily handled with a function named "smartcd_template".
#
#   To create a template based on the current directory, run:
#
#       smartcd_template create template_name
#
#   The name can be any arbitrary value, but should be meaningful to you and
#   should not contain special characters.  This will create a new template
#   named what you have chosen, and prepopulate it with the contents from
#   your current bash_enter and bash_leave scripts.  You can then edit the
#   file and save it.  When you install the template, anywhere you inserted
#   the string "__PATH__" will be replaced with the directory being set up.
#
#   To install the template, cd to a destination and run:
#
#       smartcd_template install template_name
#
#   The other available commands are:
#
#       smartcd_template list
#       smartcd_template show <name>
#       smartcd_template edit <name>
#       smartcd_template delete <name>
#
################################################################################

function smartcd() {
    local action="builtin cd"
    _smartcd "$@"
}

function smartpushd() {
    local action="builtin pushd"
    _smartcd "$@"
}

function smartpopd() {
    local action="builtin popd"
    _smartcd "$@"
}

# This variable should always have a leading "x" on it to prevent it from being
# snarfed up by autonamedirs (zsh, you crazy)

_smartcd_last_run_for=
function _smartcd() {
    # Don't run this twice consecutively from being sourced.  If the user double-sources
    # then it could result in scripts being run twice which may have undesirable or
    # unpredictable effects, so don't do that
    if [[ -n $smartcd_run_mainline ]]; then
        if [[ -n $smartcd_last_run_mainline ]]; then
            unset smartcd_run_mainline
            return
        else
            smartcd_last_run_mainline=1
        fi
    else
        unset smartcd_last_run_mainline
    fi
    unset smartcd_run_mainline

    # First, take note of where we're starting from
    local wherenow="${_smartcd_last_run_for#x}"
    local wherestarted="$wherenow"
    if [[ -z "$wherestarted" ]]; then
        wherestarted=/
        local initial_mode=1
    fi
    local run_from_smartcd=1
    local _ashift_return
    local _apop_return

    if [[ -z "$(fn_exists apush)" ]]; then
        echo "bash_arrays is not loaded, please ensure that it is installed before using smartcd"
        return
    fi

    # Go there and get the fully qualified path.  Also, fail first if it's an
    # invalid destination, before we do any more work.

    # This goofy eval syntax doesn't make a lot of sense, but it seems to work
    # correctly in both bash (4.1.5) and zsh (4.3.11).  The eval is needed
    # because "builtin cd" won't work from a zsh variable, sadly.
    if [[ -z $smartcd_skip_action ]]; then
        if [[ -n $1 ]] || [[ -z ${1-_} ]]; then
            eval "$action \"$@\""
        else
            eval $action
        fi
    fi

    if (( $? != 0 )); then return; fi;
    local whereto="$(pwd)"
    _smartcd_last_run_for="x$whereto"

    # If zsh and autopushd is set, turn it off temporarily to avoid extra pushes
    local reset_autopushd=:
    local reset_pushdignoredups=:
    if [[ -n $ZSH_VERSION ]]; then
        for opt in $(setopt); do
            if [[ $opt = "autopushd" ]]; then
                reset_autopushd="setopt autopushd"
                setopt noautopushd
            fi
            if [[ $opt = "pushdignoredups" ]]; then
                reset_pushdignoredups="setopt pushdignoredups"
                setopt nopushdignoredups
            fi
        done
    fi

    # Collect the list of directories we're leaving
    unset leave_stack
    while [[ -n $wherenow ]]; do
        apush leave_stack "$wherenow"
        wherenow="${wherenow%/*}"
    done
    if [[ -z $initial_mode ]]; then
        apush leave_stack "/"
    fi

    # Collect the list of directories we're entering
    wherenow="$whereto"
    unset enter_stack
    while [[ -n $wherenow ]]; do
        apush enter_stack "$wherenow"
        wherenow=${wherenow%/*}
    done
    apush enter_stack "/"

    # Pop off common elements
    while [[ -n "$(alast enter_stack)" ]] && [[ "$(alast enter_stack)" = "$(alast leave_stack)" ]]; do

        # Special cases for /, otherwise it would never be possible to run enter/leave for it
        if [[ "$(alen enter_stack)" = "1" ]] && [[ "$(afirst enter_stack)" = "/" ]]; then
            apop leave_stack >/dev/null
            break
        elif [[ "$(alen leave_stack)" = "1" ]] && [[ "$(afirst leave_stack)" = "/" ]]; then
            apop enter_stack >/dev/null
            break
        fi

        apop enter_stack >/dev/null
        apop leave_stack >/dev/null
    done

    # Run leave_stack in lowest to highest
    local stack_size=$(alen leave_stack)
    : ${stack_size:=0}
    while (( $stack_size >= 1 )); do
        # ashift in a sub-shell doesn't work
        local dir="$(afirst leave_stack)"
        ashift leave_stack >/dev/null
        builtin cd "$dir"
        local confdir="$HOME/.smartcd$dir"
        if [[ -f .bash_leave ]]; then
            if [[ -n $SMARTCD_LEGACY ]]; then
                if [[ -z $SMARTCD_QUIET ]]; then
                    echo "smartcd: running $dir/.bash_leave"
                fi
                . .bash_leave
            elif [[ -n $SMARTCD_AUTOMIGRATE ]]; then
                echo "Automatically migrating \"$dir/.bash_leave\" to \"$confdir/bash_leave\""
                mkdir -p "$confdir"
                cat "$dir/.bash_leave" >> "$confdir/bash_leave"
                rm "$dir/.bash_leave"
            elif [[ -z $SMARTCD_QUIET ]]; then
                echo "############################################################################"
                echo "# NOTICE!  Deprecated .bash_leave found, please migrate this file to the new"
                echo "# format using the following (or similar) commands:"
                if [[ ! -d $confdir ]]; then
                    echo "mkdir -p \"$confdir\""
                fi
                echo "cat \"$dir/.bash_leave\" >> \"$confdir/bash_leave\""
                echo "rm \"$dir/.bash_leave\""
                echo "#"
                echo "# If you would like smartcd to perform this migration for you whenever"
                echo "# possible, set SMARTCD_AUTOMIGRATE=1"
                echo "#"
                echo "# If you wish to accept the risks of the old style of operation and run"
                echo "# them as-is, you may set SMARTCD_LEGACY=1 instead."
                echo "############################################################################"
            fi
        fi
        if [[ -f "$confdir/bash_leave" ]]; then
            if [[ -z $SMARTCD_QUIET ]]; then
                echo "smartcd: running $confdir/bash_leave"
            fi
            . "$confdir/bash_leave"
        fi
        if [[ -n "$(fn_exists autounstash)" ]]; then
            autounstash
        fi

        stack_size=$(alen leave_stack)
        : ${stack_size:=0}
    done

    # Run enter_stack in highest to lowest
    local stack_size=$(alen enter_stack)
    : ${stack_size:=0}
    while (( $stack_size >= 1 )); do
        # apop in a sub-shell doesn't work
        local dir="$(alast enter_stack)"
        apop enter_stack >/dev/null
        builtin cd "$dir"
        local confdir="$HOME/.smartcd$dir"
        if [[ -f .bash_enter ]]; then
            if [[ -n $SMARTCD_LEGACY ]]; then
                if [[ -z $SMARTCD_QUIET ]]; then
                    echo "smartcd: running $dir/.bash_enter"
                fi
                . .bash_enter
            elif [[ -n $SMARTCD_AUTOMIGRATE ]]; then
                echo "Automatically migrating \"$dir/.bash_enter\" to \"$confdir/bash_enter\""
                mkdir -p "$confdir"
                cat "$dir/.bash_enter" >> "$confdir/bash_enter"
                rm "$dir/.bash_enter"
            elif [[ -z $SMARTCD_QUIET ]]; then
                echo "############################################################################"
                echo "# NOTICE!  Deprecated .bash_enter found, please migrate this file to the new"
                echo "# format using the following (or similar) commands:"
                if [[ ! -d $confdir ]]; then
                    echo "mkdir -p \"$confdir\""
                fi
                echo "cat \"$dir/.bash_enter\" >> \"$confdir/bash_enter\""
                echo "rm \"$dir/.bash_enter\""
                echo "#"
                echo "# If you would like smartcd to perform this migration for you whenever"
                echo "# possible, set SMARTCD_AUTOMIGRATE=1"
                echo "#"
                echo "# If you wish to accept the risks of the old style of operation and run"
                echo "# them as-is, you may set SMARTCD_LEGACY=1 instead."
                echo "############################################################################"
            fi
        fi
        if [[ -f "$confdir/bash_enter" ]]; then
            if [[ -z $SMARTCD_QUIET ]]; then
                echo "smartcd: running $confdir/bash_enter"
            fi
            . "$confdir/bash_enter"
        fi

        stack_size=$(alen enter_stack)
        : ${stack_size:=0}
    done

    # First go to starting directory and then jump to final directory to make "cd -" happy!
    builtin cd "$wherestarted"
    builtin cd "$whereto"

    # Turn autopushd back on, if needed.  Again, eval needed due to zsh oddness
    eval $reset_autopushd
    eval $reset_pushdignoredups
}

function smartcd_edit() {
    # Invoke the users editor (or vi) on the relevant file
    local file="$1"
    if [[ $file = "enter" || $file = "leave" ]]; then
        file="bash_$file"
    fi
    if [[ $file != "bash_enter" && $file != "bash_leave" ]]; then
        echo "Usage: smartcd_edit ( bash_enter | bash_leave )"
        return
    fi

    local smartcd_dir="$HOME/.smartcd$(pwd)"
    if [[ ! -d $smartcd_dir ]]; then
        mkdir -p "$smartcd_dir"
    fi

    ${EDITOR:-vi} "$smartcd_dir/$file"

    if [[ -f "$smartcd_dir/$file" && ! -s "$smartcd_dir/$file" ]]; then
        # Delete any file that is left empty
        rm "$smartcd_dir/$file"
    fi
}

function _smartcd_prompt_hook() {
    local cwd="$(pwd)"

    # Skip this if we already ran smartcd for this directory
    if [[ "x$cwd" != "$_smartcd_last_run_for" ]]; then
        local smartcd_skip_action=1
        _smartcd "$cwd"
    fi

    eval $_smartcd_original_prompt_command
}

function setup_smartcd_prompt_hook() {
    if [[ -n $ZSH_VERSION ]]; then
        _smartcd_original_prompt_command=:
        apush precmd_functions _smartcd_prompt_hook
    else
        if [[ -n $PROMPT_COMMAND && -z $_smartcd_original_prompt_command ]]; then
            _smartcd_original_prompt_command=$PROMPT_COMMAND
        else
            _smartcd_original_prompt_command=:
        fi

        PROMPT_COMMAND=_smartcd_prompt_hook
    fi
}

function bash_enter() {
    _smartcd_file_check bash_enter "$@"
}

function bash_leave() {
    _smartcd_file_check bash_leave "$@"
}

# It's probably better to use getopts or something for this, but since only one
# option at a time is valid right now, no need
function _smartcd_file_check() {
    local confdir="$HOME/.smartcd$(pwd)"

    local file=$1
    shift

    if [[ $1 = '-h' || $1 = 'help' ]]; then
        echo "Usage: $file [ edit | show | filename ]"
    elif [[ $1 = '-f' || $1 = 'filename' ]]; then
        echo "$confdir/$file"
    elif [[ $1 = '-e' || $1 = 'edit' ]]; then
        smartcd_edit $file
    else
        if [[ -f "$confdir/$file" ]]; then
            echo "$confdir/$file exists"
            if [[ $1 = '-l' || $1 = 'show' ]]; then
                echo "-------------------------------------------------------------------------"
                cat "$confdir/$file"
                echo "-------------------------------------------------------------------------"
            fi
        else
            echo "$confdir/$file does not exist"
        fi
    fi
}

function smartcd_template() {
    local action=$1
    shift

    local confdir="$HOME/.smartcd"

    case $action in
          _init)    local name="$1"; shift
                    local from="$1"
                    if [[ -n "$from" ]]; then
                        if [[ -f "$confdir/$from/bash_enter" ]]; then
                            local enter_orig="$(eval cat \"$confdir/$from/bash_enter\")"
                        fi
                        if [[ -f "$confdir/$from/bash_leave" ]]; then
                            local leave_orig="$(eval cat \"$confdir/$from/bash_leave\")"
                        fi
                    fi

                    if [[ ! -f "$confdir/template_$name" ]]; then
                        cat <<EOF >> "$confdir/template_$name"
########################################################################
# This is a smartcd template.  Edit this file to create a named
# configuration you can copy to any number of directories.  This is
# useful if you often use the same settings in different directories
# but with minor differences.
#
# The string __PATH__ will be replaced with the directory being
# configured when this template is installed, so you can set variables:
#
#    autostash PATH=__PATH__/bin:\$PATH
#
# This template is named '$name'
########################################################################

# Enter any bash_enter commands below here: (leave this line!)
$enter_orig

# Enter any bash_leave commands below here: (leave this line!)
$leave_orig
EOF
                    fi
                    ;;
        edit|-e)    local name="$1"; shift
                    if [[ -n $name ]]; then
                        smartcd_template _init "$name"
                        ${EDITOR:-vi} "$confdir/template_$name"
                    else
                        echo "Usage: smartcd_template edit <name>"
                    fi
                    ;;
      create|-c)    local name="$1"; shift
                    if [[ -n $name ]]; then
                        if [[ -f "$confdir/template_$name" ]]; then
                            echo "Template $name already exists, run \"smartcd_template edit $name\" to modify it"
                        else
                            smartcd_template _init "$name" "$(pwd)"
                            smartcd_template edit "$name"
                        fi
                    else
                        echo "Usage: smartcd_template create <name>"
                    fi
                    ;;
        list|-l)    for file in $confdir/template_*; do
                        # if the user has shell options that leave us with a literal asterisk here
                        # in the event of no matches, we'll want to skip it.  rather than check and
                        # twiddle shell options, let's just see if that's what happened
                        if [[ "$file" = "$confdir/template_*" ]]; then
                            break
                        fi
                        echo ${file#*template_}
                    done
                    ;;
        show|-s)    local name="$1"; shift
                    if [[ -n $name ]]; then
                        if [[ -f "$confdir/template_$name" ]]; then
                            cat "$confdir/template_$name"
                        else
                            echo "Template $name not found"
                        fi
                    else
                        echo "Usage: smartcd_template show <name>"
                    fi
                    ;;
     install|-i)    local name="$1"; shift
                    if [[ -n $name ]]; then
                        if [[ -f "$confdir/template_$name" ]]; then
                            local current_dir=$(pwd)
                            local smartcd_dir="$confdir$current_dir"
                            mkdir -p "$smartcd_dir"
                            local mode=
                            while read line; do
                                if [[ $line =~ "Enter any bash_enter commands" ]]; then
                                    mode=enter
                                    continue
                                fi
                                if [[ $line =~ "Enter any bash_leave commands" ]]; then
                                    mode=leave
                                    continue
                                fi
                                if [[ "$mode" = "enter" ]]; then
                                    if [[ -z "$notified_enter" ]]; then
                                        echo "Configuring $smartcd_dir/bash_enter from template $name"
                                        local notified_enter=1
                                    fi
                                    echo ${line//__PATH__/$current_dir} >> "$smartcd_dir/bash_enter"
                                elif [[ "$mode" = "leave" ]]; then
                                    if [[ -z "$notified_leave" ]]; then
                                        echo "Configuring $smartcd_dir/bash_leave from template $name"
                                        local notified_leave=1
                                    fi
                                    echo ${line//__PATH__/$current_dir} >> "$smartcd_dir/bash_leave"
                                fi
                            done < "$confdir/template_$name"
                        else
                            echo "Template $name not found"
                        fi
                    else
                        echo "Usage: smartcd_template install <name>"
                    fi
                    ;;
      delete|rm|-d) local name="$1"; shift
                    if [[ -n $name ]]; then
                        if [[ -f "$confdir/template_$name" ]]; then
                            rm "$confdir/template_$name"
                        else
                            echo "Template $name not found"
                        fi
                    else
                        echo "Usage: smartcd_template delete <name>"
                    fi
                    ;;
              *)    echo "Unknown action $action."
                    echo "Usage: smartcd_template ( edit | create | list | show | install | delete ) [args]"
                    ;;
    esac
}

function fn_exists() {
    if [[ -n "$(declare -f $1)" ]]; then
        echo 1
    fi
}

# Run on load if all the necessary libraries are loaded, otherwise let them do it
if [[ -n "$(fn_exists apush)" && -n "$(fn_exists autostash)" && -z "$SMARTCD_NOINITIAL" ]]; then
    smartcd_skip_action=1
    smartcd_run_mainline=1
    smartcd
    unset smartcd_skip_action
else
    smartcd_initially_deferred=1
fi
