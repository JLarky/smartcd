#!/bin/bash

################################################################################
# bash_smartcd - cd with some oomph
#
#   Copyright (c) 2009-10 Dave Olszewski <cxreg@pobox.com>
#   http://github.com/cxreg/smartcd
#
#   This code is released under GPL v2 and the Artistic License, and
#   may be redistributed under the terms of either.
#
#
#   ###########
#   # Summary #
#   ###########
#
#   This replacement for bash's built-in cd function gives you the
#   ability to run bash_enter and bash_leave scripts for each of
#   the directories you are traveling between.  The scripts are run
#   in the expected order to the most common root between where you
#   are, and where you're going.  These files reside in a hierarchy
#   under your home directory which mirrors the directories they
#   represent, for example:
#
#       /foo/bar/baz  ->  ~/.smartcd/foo/bar/baz
#
#   ###############
#   # Basic usage #
#   ###############
#
#       # Install the library
#       cp .bash_smartcd ~
#
#       # Add it to your bash init script
#       . ~/.bash_smartcd
#       alias cd=smartcd
#
#       # And it works with pushd/popd too
#       alias pushd=smartpushd
#       alias popd=smartpopd
#
#       # Create some custom directives
#       echo 'echo "hi!"' > ~/.smartcd/somedir/bash_enter
#
#   This library combines very nicely with .bash_varstash to allow
#   you to set per-directory environment variables:
#
#       # bash_enter
#       stash PATH
#       export PATH=/something/extra:$PATH
#
#       # bash_leave
#       unstash PATH
#
#       # or the automagic version, which unstashes for you
#       autostash PATH
#       export PATH=/something/extra:$PATH
#
#   When a script is run by smartcd, it will announce that it has done
#   so unless SMARTCD_QUIET is set.
#
#   ########################
#   # Legacy mode (unsafe) #
#   ########################
#
#   The original version of this library was such that the scripts
#   containing the commands to run were themselves located in the
#   directory which they correspond to, named .bash_enter and
#   .bash_leave:
#
#       /foo/bar/baz  ->  /foo/bar/baz/.bash_enter
#
#   This was deemed unsafe, and the new scheme was adopted.  If you
#   prefer the old system and wish to accept the risk in doing so, you
#   can set SMARTCD_LEGACY to allow the old behavior.  If you do not do
#   so, and a legacy script is found, it will *NOT* be invoked, and
#   instructions for migrating it to the new location will be displayed
#   (unless SMARTCD_QUIET is set).
#
################################################################################

function smartcd() {
    local action="builtin cd"
    _smartcd "$@"
}

function smartpushd() {
    local action="builtin pushd"
    _smartcd "$@"
}

function smartpopd() {
    local action="builtin popd"
    _smartcd "$@"
}

function _smartcd() {
    # First, take note of where we're starting from
    local wherenow=$(pwd)
    local run_from_smartcd=1

    if [[ -n $ZSH_VERSION ]]; then
        if [[ $(type apush) != "apush is a shell function" ]]; then
            echo "bash_arrays is not loaded, please ensure that it is installed before using smartcd"
            return
        fi
    else
        if [[ $(type -t apush) != "function" ]]; then
            echo "bash_arrays is not loaded, please ensure that it is installed before using smartcd"
            return
        fi
    fi

    # Go there and get the fully qualified path.  Also, fail first if it's an
    # invalid destination, before we do any more work.

    # This goofy eval syntax doesn't make a lot of sense, but it seems to work
    # correctly in both bash (4.1.5) and zsh (4.3.11).  The eval is needed
    # because "builtin cd" won't work from a zsh variable, sadly.
    if [[ -n $1 ]] || [[ -z ${1-_} ]]; then
        eval "$action \"$@\""
    else
        eval $action
    fi

    if (( $? != 0 )); then return; fi;
    local whereto=$(pwd)

    # If zsh and autopushd is set, turn it off temporarily to avoid extra pushes
    if [[ -n $ZSH_VERSION ]] && [[ -n "$(setopt | grep autopushd)" ]]; then
        local reset_autopushd="setopt autopushd"
        setopt noautopushd
    else
        local reset_autopushd=:
    fi

    # Collect the list of directories we're leaving
    unset leave_stack
    while [[ $wherenow != "/" ]]; do
        apush leave_stack "$wherenow"
        wherenow=$(dirname "$wherenow")
    done
    apush leave_stack "/"

    # Collect the list of directories we're entering
    local wherenow=$whereto
    unset enter_stack
    while [[ $wherenow != "/" ]]; do
        apush enter_stack "$wherenow"
        wherenow=$(dirname "$wherenow")
    done
    apush enter_stack "/"

    # Pop off common elements
    while [[ -n "$(alast enter_stack)" ]] && [[ "$(alast enter_stack)" = "$(alast leave_stack)" ]]; do

        # Special cases for /, otherwise it would never be possible to run enter/leave for it
        if [[ "$(alen enter_stack)" = "1" ]] && [[ "$(afirst enter_stack)" = "/" ]]; then
            apop leave_stack >/dev/null
            break
        elif [[ "$(alen leave_stack)" = "1" ]] && [[ "$(afirst leave_stack)" = "/" ]]; then
            apop enter_stack >/dev/null
            break
        fi

        apop enter_stack >/dev/null
        apop leave_stack >/dev/null
    done

    # Run leave_stack in lowest to highest
    while (( $(alen leave_stack) >= 1 )); do
        # ashift in a sub-shell doesn't work
        local dir=$(afirst leave_stack);
        ashift leave_stack >/dev/null
        builtin cd "$dir"
        local confdir="$HOME/.smartcd$dir"
        if [[ -f .bash_leave ]]; then
            if [[ -n $SMARTCD_LEGACY ]]; then
                if [[ -z $SMARTCD_QUIET ]]; then
                    echo "smartcd: running $dir/.bash_leave"
                fi
                . .bash_leave
            elif [[ -z $SMARTCD_QUIET ]]; then
                echo "############################################################################"
                echo "# NOTICE!  Deprecated .bash_leave found, please migrate this file to the new"
                echo "# format using the following (or similar) commands:"
                if [[ ! -d $confdir ]]; then
                    echo "mkdir -p \"$confdir\""
                fi
                echo "cat \"$dir/.bash_leave\" >> \"$confdir/bash_leave\""
                echo "rm \"$dir/.bash_leave\""
                echo "############################################################################"
            fi
        fi
        if [[ -f "$confdir/bash_leave" ]]; then
            if [[ -z $SMARTCD_QUIET ]]; then
                echo "smartcd: running $confdir/bash_leave"
            fi
            . "$confdir/bash_leave"
        fi
        if [[ -n $ZSH_VERSION ]]; then
            if [[ $(type autounstash) = "autounstash is a shell function" ]]; then
                autounstash
            fi
        else
            if [[ $(type -t autounstash) = "function" ]]; then
                autounstash
            fi
        fi
    done

    # Run enter_stack in highest to lowest
    while (( $(alen enter_stack) >= 1 )); do
        # apop in a sub-shell doesn't work
        local dir=$(alast enter_stack);
        apop enter_stack >/dev/null
        builtin cd "$dir"
        local confdir="$HOME/.smartcd$dir"
        if [[ -f .bash_enter ]]; then
            if [[ -n $SMARTCD_LEGACY ]]; then
                if [[ -z $SMARTCD_QUIET ]]; then
                    echo "smartcd: running $dir/.bash_enter"
                fi
                . .bash_enter
            elif [[ -z $SMARTCD_QUIET ]]; then
                echo "############################################################################"
                echo "# NOTICE!  Deprecated .bash_enter found, please migrate this file to the new"
                echo "# format using the following (or similar) commands:"
                if [[ ! -d $confdir ]]; then
                    echo "mkdir -p \"$confdir\""
                fi
                echo "cat \"$dir/.bash_enter\" >> \"$confdir/bash_enter\""
                echo "rm \"$dir/.bash_enter\""
                echo "############################################################################"
            fi
        fi
        if [[ -f "$confdir/bash_enter" ]]; then
            if [[ -z $SMARTCD_QUIET ]]; then
                echo "smartcd: running $confdir/bash_enter"
            fi
            . "$confdir/bash_enter"
        fi
    done

    # Go and be happy
    builtin cd "$whereto"

    # Turn autopushd back on, if needed.  Again, eval needed due to zsh oddness
    eval $reset_autopushd
}

function smartcd_edit() {
    # Invoke the users editor (or vi) on the relevant file
    file=$1
    if [[ $file = "enter" || $file = "leave" ]]; then
        file="bash_$file"
    fi
    if [[ $file != "bash_enter" && $file != "bash_leave" ]]; then
        echo "Usage: smartcd_edit ( bash_enter | bash_leave )"
        return
    fi

    local smartcd_dir=$HOME/.smartcd$(pwd)
    if [[ ! -d $smartcd_dir ]]; then
        mkdir -p "$smartcd_dir"
    fi

    ${EDITOR:-vi} $smartcd_dir/$file
}
